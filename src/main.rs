/*
Sorts (for example):

/path/to/books/
├── authors
│   ├── Cat Dog
│   └── Matt Smith
│       └── Book Title - Smith, Matt.txt    # contents: "og contents"
└── unsorted
    ├── Book Title by Matt Smith.txt
    ├── Book_Title_Matt_Smith.txt
    ├── Book Title - Smith, Matt.txt        # contents: "new contents"
    ├── Cat, Dog.txt
    ├── Dog, Cat.txt
    ├── I like Cats and Dogs.txt
    ├── Johnathon Smith - Matt's adventures.txt
    ├── Smith, Matt - Book_Title.txt
    └── wtf Matt_Smith.txt

into:

/path/to/books/
├── authors
│   ├── Cat Dog
│   │   ├── Cat, Dog.txt
│   │   └── Dog, Cat.txt
│   └── Matt Smith
│       ├── Book Title - Smith, Matt.txt                # contents: "og contents"
│       ├── Book Title - Smith, Matt - 438758927349.txt # contents: "new contents"
│       ├── Book Title by Matt Smith.txt
│       ├── Book_Title_Matt_Smith.txt
│       ├── Smith, Matt - Book_Title.txt
│       └── wtf Matt_Smith.txt
└── unsorted
    ├── I like Cats and Dogs.txt
    └── Johnathon Smith - Matt's adventures.txt

Basically, it sorts files into folders based on the author's name.
If the book is already in the correct folder, it will be renamed to avoid
overwriting the existing file. The new filename will be the original filename
with ` - <current time in nanoseconds>.txt` appended to it.

The author name is determined by matching the filename against keywords. The
keywords are generated by splitting the name of the author's folder by spaces.
For example, the author "Matt Smith" would generate the keywords "Matt" and
"Smith".

The keywords are then used to match against the filename. If it matches, the
file is moved into the author's folder.

Matching is done by making sure the filename contains all the keywords in any
order, and that the keywords are separated by no more than two non-alphanumeric
characters. For example, with the keywords "Matt" and "Smith", the following
filenames would match:

    Book Title - Smith, Matt.txt
    Book Title by Matt Smith.txt
    Book_Title_Matt_Smith.txt
    Smith, Matt - Book_Title.txt
    wtf Matt_Smith.txt

The following filenames would not match:

    Johnathon Smith - Matt's adventures.txt
    Cat, Dog.txt
    Dog, Cat.txt
    I like Cats and Dogs.txt
*/

use std::env;
use std::fs;
use std::fs::OpenOptions;
use std::io::Write;
use std::path::Path;
use std::path::PathBuf;

trait OptWrite {
    fn write(&mut self, buf: &[u8]) -> std::io::Result<usize>;
}

impl OptWrite for Option<&mut fs::File> {
    fn write(&mut self, buf: &[u8]) -> std::io::Result<usize> {
        if let Some(file) = self {
            file.write(buf)
        } else {
            Ok(0)
        }
    }
}

fn matches_keywords(filename: &str, keywords: &Vec<String>) -> bool {
    let mut indexes = Vec::new();

    for keyword in keywords {
        let index = filename.find(keyword);
        if index.is_none() {
            return false;
        }
        let index = index.unwrap();
        indexes.push((index, index + keyword.len()));
    }

    indexes.sort_by(|a, b| a.0.cmp(&b.0));

    let mut last_end = indexes[0].1;
    for (start, end) in indexes.iter().skip(1) {
        if start - last_end > 2 {
            return false;
        }
        last_end = *end;
    }

    true
}

fn get_keywords(author: &str) -> Vec<String> {
    author
        .split(' ')
        .map(|s| s.to_string().to_lowercase())
        .collect()
}

fn main() {
    let args: Vec<String> = env::args().collect();
    if args.len() < 3 {
        println!("Usage: {} <authors> <unsorted> [-v]", args[0]);
        return;
    }

    let use_verbose_log = args.len() == 4 && args[3] == "-v";

    let authors_dir = Path::new(&args[1]);
    let unsorted_dir = Path::new(&args[2]);

    if !authors_dir.is_dir() {
        println!("{} is not a directory", authors_dir.display());
        return;
    }

    if !unsorted_dir.is_dir() {
        println!("{} is not a directory", unsorted_dir.display());
        return;
    }

    let mut authors = Vec::new();
    for entry in fs::read_dir(authors_dir).unwrap() {
        let entry = entry.unwrap();
        let path = entry.path();
        if path.is_dir() {
            let filename = path.file_name().unwrap().to_str().unwrap();
            let keywords = get_keywords(filename);
            authors.push((keywords, filename.to_owned(), path));
        }
    }

    // Open the log file in append mode
    let mut log_file = OpenOptions::new()
        .write(true)
        .append(true)
        .create(true)
        .open("log.txt")
        .unwrap();

    // Open the log file in append mode
    let mut verbose_log_file = if use_verbose_log {
        Some(
            OpenOptions::new()
                .write(true)
                .append(true)
                .create(true)
                .open("verbose_log.txt")
                .unwrap(),
        )
    } else {
        None
    };

    log_file
        .write(format!("\n\nAuthors: {}\nUnsorted: {}\n\n", args[1], args[2]).as_bytes())
        .unwrap();

    verbose_log_file
        .as_mut()
        .write(format!("\n\nAuthors: {}\nUnsorted: {}\n\n", args[1], args[2]).as_bytes())
        .unwrap();

    let unordered_dir = fs::read_dir(unsorted_dir).unwrap();
    fun_name(unordered_dir, authors, &log_file, &mut verbose_log_file.as_mut());
}

fn fun_name(
    unordered_dir: fs::ReadDir,
    authors: Vec<(Vec<String>, String, PathBuf)>,
    mut log_file: &fs::File,
    verbose_log_file: &mut Option<&mut fs::File>,
) {
    for entry in unordered_dir {
        let entry = entry.unwrap();
        let path = entry.path();

        verbose_log_file
            .write(format!("(Chck) `{}`\n", path.display()).as_bytes())
            .unwrap();

        if path.is_file() {
            let filename = path
                .clone()
                .file_name()
                .unwrap()
                .to_str()
                .unwrap()
                .to_owned();

            let lower_filename = filename.to_lowercase();

            for (keywords, author_name, author_path) in &authors {
                verbose_log_file
                    .write(
                        format!("(Chck) `{}` against `{}`\n", lower_filename, author_name).as_bytes(),
                    )
                    .unwrap();

                if matches_keywords(&lower_filename, &keywords) {
                    let new_path = PathBuf::from(author_path).join(&filename);
                    let mut log = format!("[Move] `{}`\tto\t`{}`\n", author_name, filename);
                    if !new_path.exists() {
                        println!("Moved: `{}`\tfor\t`{}`", author_name, filename);

                        fs::rename(path, new_path).unwrap();
                    } else {
                        println!("Duplicate: `{}`\tfor\t`{}`", author_name, filename);

                        let mut new_filename =
                            path.file_stem().unwrap().to_str().unwrap().to_owned();
                        let extension = path.extension().unwrap().to_str().unwrap();
                        new_filename.push_str(" - ");
                        new_filename.push_str(
                            &std::time::SystemTime::now()
                                .duration_since(std::time::UNIX_EPOCH)
                                .unwrap()
                                .as_nanos()
                                .to_string(),
                        );
                        new_filename.push('.');
                        new_filename.push_str(extension);

                        log = format!("-Dupl- `{}`\tto\t`{}`\n", author_name, new_filename);

                        let new_path = PathBuf::from(author_path).join(new_filename);
                        fs::rename(path, new_path).unwrap();
                    }
                    log_file.write(log.as_bytes()).unwrap();
                    verbose_log_file.write(log.as_bytes()).unwrap();
                    break;
                }
            }
        } else {
            verbose_log_file
                .write(format!("(Dir) `{}`\n", path.display()).as_bytes())
                .unwrap();

            let unordered_dir = fs::read_dir(path).unwrap();

            fun_name(unordered_dir, authors.clone(), log_file, verbose_log_file);
        }
    }
}
