/*
Sorts (for example):

/path/to/books/
├── authors
│   ├── Cat Dog
│   └── Matt Smith
│       └── Book Title - Smith, Matt.txt    # contents: "og contents"
└── unsorted
    ├── Book Title by Matt Smith.txt
    ├── Book_Title_Matt_Smith.txt
    ├── Book Title - Smith, Matt.txt        # contents: "new contents"
    ├── Cat, Dog.txt
    ├── Dog, Cat.txt
    ├── I like Cats and Dogs.txt
    ├── Johnathon Smith - The adventures of Matt.txt
    ├── Smith, Matt - Book_Title.txt
    └── wtf Matt_Smith.txt

into:

/path/to/books/
├── authors
│   ├── Cat Dog
│   │   ├── Cat, Dog.txt
│   │   └── Dog, Cat.txt
│   └── Matt Smith
│       ├── Book Title - Smith, Matt.txt                # contents: "og contents"
│       ├── Book Title - Smith, Matt - 438758927349.txt # contents: "new contents"
│       ├── Book Title by Matt Smith.txt
│       ├── Book_Title_Matt_Smith.txt
│       ├── Smith, Matt - Book_Title.txt
│       └── wtf Matt_Smith.txt
└── unsorted
    ├── I like Cats and Dogs.txt
    └── Johnathon Smith - The adventures of Matt.txt

Basically, it sorts files into folders based on the author's name.
If the book is already in the correct folder, it will be renamed to avoid
overwriting the existing file. The new filename will be the original filename
with ` - <current time in nanoseconds>.txt` appended to it.

The author name is determined by matching the filename against keywords. The
keywords are generated by splitting the name of the author's folder by spaces.
For example, the author "Matt Smith" would generate the keywords "Matt" and
"Smith".

The keywords are then used to match against the filename. If it matches, the
file is moved into the author's folder.

Matching is done by making sure the filename contains all the keywords in any
order, and that the keywords are separated by no more than two non-alphanumeric
characters. For example, with the keywords "Matt" and "Smith", the following
filenames would match:

    Book Title - Smith, Matt.txt
    Book Title by Matt Smith.txt
    Book_Title_Matt_Smith.txt
    Smith, Matt - Book_Title.txt
    wtf Matt_Smith.txt

The following filenames would not match:

    Johnathon Smith - The adventures of Matt.txt
    Cat, Dog.txt
    Dog, Cat.txt
    I like Cats and Dogs.txt
*/

use std::env;
use std::fs;
use std::fs::OpenOptions;
use std::io::Write;
use std::path::Path;
use std::path::PathBuf;

trait OptWrite {
    fn write(&mut self, buf: &[u8]) -> std::io::Result<usize>;
}

impl OptWrite for Option<&mut fs::File> {
    fn write(&mut self, buf: &[u8]) -> std::io::Result<usize> {
        if let Some(file) = self {
            file.write(buf)
        } else {
            Ok(0)
        }
    }
}

fn matches_keywords(filename: &str, keywords: &Vec<String>) -> bool {
    let mut all_indexes = Vec::new();

    for keyword in keywords {
        let index = filename.find(keyword);
        if index.is_none() {
            return false;
        }
        let index = index.unwrap();
        all_indexes.push((index, index + keyword.len()));
    }

    all_indexes.sort_by(|a, b| a.0.cmp(&b.0));

    println!("indexes: {:?}", all_indexes);

    let mut last_end = all_indexes[0].1;
    for (start, end) in all_indexes.iter().skip(1) {
        if *start < last_end {
            return false;
        }
        if start - last_end > 2 {
            return false;
        }
        for c in filename.chars().skip(last_end).take(*start - last_end) {
            if c.is_alphanumeric() {
                return false;
            }
        }
        last_end = *end;
    }

    true
}

#[test]
fn test_matches() {
    let author_titles: Vec<(&str, &str)> = vec![
        ("C S Lewis", "Mere Christianity - Lewis_ C.S_") // doesn't match.
        // Reason:
        // - A first "C" is found in the 6th character
        // - A first "S" is found in the 10th character
        // - "Lewis" is found in the 21st character
        // The first "C" and "S" are separated by 3 characters, which is more than 2.
        // The first "S" and "Lewis" are separated by 11 characters, which is more than 2.
        // Ideally, we would match all the characters, so for example "C" would be found in
        // the 6th character and the 28th character, and "S" would be found in the 10th
        // character, the 25th character, and the 30th character.
    ];

    for (author, title) in author_titles {
        let keywords = get_keywords(author);
        let title = title.to_lowercase();
        assert!(matches_keywords(&title, &keywords));
    }
}

fn get_keywords(author: &str) -> Vec<String> {
    author
        .split(' ')
        .map(|s| s.to_string().to_lowercase())
        .collect()
}

fn main() {
    let args: Vec<String> = env::args().collect();
    if args.len() < 3 {
        println!("Usage: {} <authors> <unsorted> [-v]", args[0]);
        return;
    }

    let use_verbose_log = args.len() == 4 && args[3] == "-v";

    let authors_dir = Path::new(&args[1]);
    let unsorted_dir = Path::new(&args[2]);

    if !authors_dir.is_dir() {
        println!("{} is not a directory", authors_dir.display());
        return;
    }

    if !unsorted_dir.is_dir() {
        println!("{} is not a directory", unsorted_dir.display());
        return;
    }

    let mut authors = Vec::new();
    for entry in fs::read_dir(authors_dir).unwrap() {
        let entry = entry.unwrap();
        let path = entry.path();
        if path.is_dir() {
            let filename = path.file_name().unwrap().to_str().unwrap();
            let keywords = get_keywords(filename);
            authors.push((keywords, filename.to_owned(), path));
        }
    }

    // Open the log file in append mode
    let mut log_file = OpenOptions::new()
        .write(true)
        .append(true)
        .create(true)
        .open("log.txt")
        .unwrap();

    // Open the log file in append mode
    let mut verbose_log_file = if use_verbose_log {
        Some(
            OpenOptions::new()
                .write(true)
                .append(true)
                .create(true)
                .open("verbose_log.txt")
                .unwrap(),
        )
    } else {
        None
    };

    log_file
        .write(format!("\n\nAuthors: {}\nUnsorted: {}\n\n", args[1], args[2]).as_bytes())
        .unwrap();

    verbose_log_file
        .as_mut()
        .write(format!("\n\nAuthors: {}\nUnsorted: {}\n\n", args[1], args[2]).as_bytes())
        .unwrap();

    fun_name(
        unsorted_dir,
        &authors,
        &log_file,
        &mut verbose_log_file.as_mut(),
    );
}

fn fun_name(
    unordered_dir: &Path,
    authors: &Vec<(Vec<String>, String, PathBuf)>,
    mut log_file: &fs::File,
    verbose_log_file: &mut Option<&mut fs::File>,
) {
    let unordered_dir = fs::read_dir(unordered_dir).unwrap();
    let unordered_paths = unordered_dir
        .map(|entry| entry.unwrap().path())
        .collect::<Vec<_>>();
    for (keywords, author_name, author_path) in authors {
        verbose_log_file
            .write(format!("Author `{}`\n", author_name).as_bytes())
            .unwrap();

        for path in &unordered_paths {
            if path.is_file() {
                let filename = path
                    .clone()
                    .file_name()
                    .unwrap()
                    .to_str()
                    .unwrap()
                    .to_owned();

                let lower_filename = filename.to_lowercase();

                verbose_log_file
                    .write(
                        format!(" Check `{}` for `{}`\n", author_name, lower_filename).as_bytes(),
                    )
                    .unwrap();

                if matches_keywords(&lower_filename, &keywords) {
                    let new_path = PathBuf::from(author_path).join(&filename);
                    let mut log = format!("[Move] `{}`\tto\t`{}`\n", author_name, filename);
                    if !new_path.exists() {
                        println!("Moved: `{}`\tfor\t`{}`", author_name, filename);

                        fs::rename(path, new_path).unwrap();
                    } else {
                        println!("Duplicate: `{}`\tfor\t`{}`", author_name, filename);

                        let mut new_filename =
                            path.file_stem().unwrap().to_str().unwrap().to_owned();
                        let extension = path.extension().unwrap().to_str().unwrap();
                        new_filename.push_str(" - ");
                        new_filename.push_str(
                            &std::time::SystemTime::now()
                                .duration_since(std::time::UNIX_EPOCH)
                                .unwrap()
                                .as_nanos()
                                .to_string(),
                        );
                        new_filename.push('.');
                        new_filename.push_str(extension);

                        log = format!("-Dupl- `{}`\tto\t`{}`\n", author_name, new_filename);

                        let new_path = PathBuf::from(author_path).join(new_filename);
                        fs::rename(path, new_path).unwrap();
                    }
                    log_file.write(log.as_bytes()).unwrap();
                    verbose_log_file.write(log.as_bytes()).unwrap();
                    continue;
                }
            } else if path.is_dir() {
                verbose_log_file
                    .write(format!("(Dir ) `{}`\n", path.display()).as_bytes())
                    .unwrap();

                fun_name(&path, &authors, log_file, verbose_log_file);
            }
        }
    }
}
