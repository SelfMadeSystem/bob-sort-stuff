/*
Sorts (for example):

/path/to/books/
├── authors
│   ├── Cat Dog
│   └── Matt Smith
│       └── Book Title - Smith, Matt.txt    # contents: "og contents"
└── unsorted
    ├── Book Title by Matt Smith.txt
    ├── Book_Title_Matt_Smith.txt
    ├── Book Title - Smith, Matt.txt        # contents: "new contents"
    ├── Cat, Dog.txt
    ├── Dog, Cat.txt
    ├── I like Cats and Dogs.txt
    ├── Johnathon Smith - The adventures of Matt.txt
    ├── Smith, Matt - Book_Title.txt
    └── wtf Matt_Smith.txt

into:

/path/to/books/
├── authors
│   ├── Cat Dog
│   │   ├── Cat, Dog.txt
│   │   └── Dog, Cat.txt
│   └── Matt Smith
│       ├── Book Title - Smith, Matt.txt                # contents: "og contents"
│       ├── Book Title - Smith, Matt - 438758927349.txt # contents: "new contents"
│       ├── Book Title by Matt Smith.txt
│       ├── Book_Title_Matt_Smith.txt
│       ├── Smith, Matt - Book_Title.txt
│       └── wtf Matt_Smith.txt
└── unsorted
    ├── I like Cats and Dogs.txt
    └── Johnathon Smith - The adventures of Matt.txt

Basically, it sorts files into folders based on the author's name.
If the book is already in the correct folder, it will be renamed to avoid
overwriting the existing file. The new filename will be the original filename
with ` - <current time in nanoseconds>.txt` appended to it.

The author name is determined by matching the filename against keywords. The
keywords are generated by splitting the name of the author's folder by spaces.
For example, the author "Matt Smith" would generate the keywords "Matt" and
"Smith".

The keywords are then used to match against the filename. If it matches, the
file is moved into the author's folder.

Matching is done by making sure the filename contains all the keywords in any
order, and that the keywords are separated by no more than two non-alphanumeric
characters. For example, with the keywords "Matt" and "Smith", the following
filenames would match:

    Book Title - Smith, Matt.txt
    Book Title by Matt Smith.txt
    Book_Title_Matt_Smith.txt
    Smith, Matt - Book_Title.txt
    wtf Matt_Smith.txt

The following filenames would not match:

    Johnathon Smith - The adventures of Matt.txt
    Cat, Dog.txt
    Dog, Cat.txt
    I like Cats and Dogs.txt
*/

use std::env;
use std::fs;
use std::fs::OpenOptions;
use std::io::Write;
use std::path::Path;
use std::path::PathBuf;

trait OptWrite {
    fn write(&mut self, buf: &[u8]) -> std::io::Result<usize>;
}

impl OptWrite for Option<&mut fs::File> {
    fn write(&mut self, buf: &[u8]) -> std::io::Result<usize> {
        if let Some(file) = self {
            file.write(buf)
        } else {
            Ok(0)
        }
    }
}

trait Between {
    /// If `self` and `other` overlap, returns None.
    /// Otherwise, returns the start and end indexes of the gap between `self` and `other`.
    ///
    /// # Examples
    ///
    /// ```
    /// assert_eq!(Some((3, 5)), (0, 3).between(&(5, 10)));
    /// assert_eq!(Some((3, 5)), (5, 10).between(&(0, 3)));
    /// assert_eq!(Some((3, 3)), (0, 3).between(&(3, 5)));
    /// assert_eq!(None, (0, 3).between(&(2, 5)));
    /// ```
    fn between(&self, other: &Self) -> Option<(usize, usize)>;
}

impl Between for (usize, usize) {
    fn between(&self, other: &Self) -> Option<(usize, usize)> {
        if self.0 < other.0 {
            if self.1 <= other.0 {
                Some((self.1, other.0))
            } else {
                None
            }
        } else {
            if other.1 <= self.0 {
                Some((other.1, self.0))
            } else {
                None
            }
        }
    }
}

fn matches_keywords(filename: &str, keywords: &Vec<String>) -> bool {
    let mut all_indexes = Vec::new();

    for keyword in keywords {
        let matches = filename.match_indices(keyword).collect::<Vec<_>>();

        if matches.is_empty() {
            return false;
        }

        all_indexes.push(
            matches
                .into_iter()
                .map(|(i, s)| (i, i + s.len()))
                .collect::<Vec<_>>(),
        );
    }

    for indexes in all_indexes.first().expect("all_indexes is empty") {
        if submatches(0, filename, &mut vec![indexes.clone()], indexes, &all_indexes) {
            return true;
        }
    }

    false
}

fn submatches(
    arg: i32,
    filename: &str,
    mut current_indicies: &mut Vec<(usize, usize)>,
    indexes: &(usize, usize),
    all_indexes: &[Vec<(usize, usize)>],
) -> bool {
    if arg == all_indexes.len() as i32 - 1 {
        return true;
    }

    let next_indexes = all_indexes[arg as usize + 1].clone();

    for next_indexes in next_indexes {
        if let Some((start, end)) = indexes.between(&next_indexes) {
            if end - start <= 2 {
                // make sure the gap between doesn't contain any alphanumeric characters
                let gap = &filename[start..end];
                if gap.chars().any(|c| c.is_alphanumeric()) {
                    continue;
                }
                current_indicies.push(next_indexes.clone());
                if submatches(
                    arg + 1,
                    filename,
                    &mut current_indicies,
                    &(next_indexes.0.min(indexes.0), next_indexes.1.max(indexes.1)),
                    all_indexes,
                ) {
                    return true;
                }
            }
        } else {
            for current in current_indicies.clone() {
                if let Some((start, end)) = current.between(&next_indexes) {
                    if end - start <= 2 {
                        // make sure the gap between doesn't contain any alphanumeric characters
                        let gap = &filename[start..end];
                        if gap.chars().any(|c| c.is_alphanumeric()) {
                            continue;
                        }
                        current_indicies.push(next_indexes.clone());
                        if submatches(
                            arg + 1,
                            filename,
                            &mut current_indicies,
                            &(next_indexes.0.min(current.0), next_indexes.1.max(current.1)),
                            all_indexes,
                        ) {
                            return true;
                        }
                    }
                }
            }
        }
    }

    false
}

#[test]
fn test_matches() {
    let author_titles = vec![
        (
            "C S Lewis",
            vec![
                ("Mere Christianity - Lewis_ C.S_", true),
                (
                    "Space Trilogy 1 - Out Of The Silent Plan - Lewis_ C.S_",
                    true,
                ),
            ],
        ),
        (
            "Matt Smith",
            vec![
                ("Book Title - Smith, Matt.txt", true),
                ("Book Title by Matt Smith.txt", true),
                ("Book_Title_Matt_Smith.txt", true),
                ("Smith, Matt - Book_Title.txt", true),
                ("wtf Matt_Smith.txt", true),
                ("Johnathon Smith - The adventures of Matt.txt", false),
                ("Cat, Dog.txt", false),
                ("Dog, Cat.txt", false),
                ("I like Cats and Dogs.txt", false),
            ],
        ),
        (
            "T H White",
            vec![
                ("The.Last.Lie.by.Stephen.White", false),
                ("White Gold Wielder - Stephen R. Donaldson", false),
                ("The Sword In The Stone - T. H. White", true),
            ],
        ),
    ];

    for (author, titles) in author_titles {
        let keywords = get_keywords(author);
        for (title, bool) in titles {
            let title = title.to_lowercase();
            assert!(matches_keywords(&title, &keywords) == bool);
        }
    }
}

fn get_keywords(author: &str) -> Vec<String> {
    author
        .split(' ')
        .map(|s| s.to_string().to_lowercase())
        .collect()
}

fn main() {
    let args: Vec<String> = env::args().collect();
    if args.len() < 3 {
        println!("Usage: {} <authors> <unsorted> [-v]", args[0]);
        return;
    }

    let use_verbose_log = args.len() == 4 && args[3] == "-v";

    let authors_dir = Path::new(&args[1]);
    let unsorted_dir = Path::new(&args[2]);

    if !authors_dir.is_dir() {
        println!("{} is not a directory", authors_dir.display());
        return;
    }

    if !unsorted_dir.is_dir() {
        println!("{} is not a directory", unsorted_dir.display());
        return;
    }

    let mut authors = Vec::new();
    for entry in fs::read_dir(authors_dir).unwrap() {
        let entry = entry.unwrap();
        let path = entry.path();
        if path.is_dir() {
            let filename = path.file_name().unwrap().to_str().unwrap();
            let keywords = get_keywords(filename);
            authors.push((keywords, filename.to_owned(), path));
        }
    }

    // Open the log file in append mode
    let mut log_file = OpenOptions::new()
        .write(true)
        .append(true)
        .create(true)
        .open("log.txt")
        .unwrap();

    // Open the log file in append mode
    let mut verbose_log_file = if use_verbose_log {
        Some(
            OpenOptions::new()
                .write(true)
                .append(true)
                .create(true)
                .open("verbose_log.txt")
                .unwrap(),
        )
    } else {
        None
    };

    log_file
        .write(format!("\n\nAuthors: {}\nUnsorted: {}\n\n", args[1], args[2]).as_bytes())
        .unwrap();

    verbose_log_file
        .as_mut()
        .write(format!("\n\nAuthors: {}\nUnsorted: {}\n\n", args[1], args[2]).as_bytes())
        .unwrap();

    fun_name(
        unsorted_dir,
        &authors,
        &log_file,
        &mut verbose_log_file.as_mut(),
    );
}

fn fun_name(
    unordered_dir: &Path,
    authors: &Vec<(Vec<String>, String, PathBuf)>,
    mut log_file: &fs::File,
    verbose_log_file: &mut Option<&mut fs::File>,
) {
    let unordered_dir = fs::read_dir(unordered_dir).unwrap();
    let unordered_paths = unordered_dir
        .map(|entry| entry.unwrap().path())
        .collect::<Vec<_>>();
    for (keywords, author_name, author_path) in authors {
        verbose_log_file
            .write(format!("Author `{}`\n", author_name).as_bytes())
            .unwrap();

        for path in &unordered_paths {
            if path.is_file() {
                let filename = path
                    .clone()
                    .file_name()
                    .unwrap()
                    .to_str()
                    .unwrap()
                    .to_owned();

                let lower_filename = filename.to_lowercase();

                verbose_log_file
                    .write(
                        format!(" Check `{}` for `{}`\n", author_name, lower_filename).as_bytes(),
                    )
                    .unwrap();

                if matches_keywords(&lower_filename, &keywords) {
                    let new_path = PathBuf::from(author_path).join(&filename);
                    let mut log = format!("[Move] `{}`\tto\t`{}`\n", author_name, filename);
                    if !new_path.exists() {
                        println!("Moved: `{}`\tfor\t`{}`", author_name, filename);

                        fs::rename(path, new_path).unwrap();
                    } else {
                        println!("Duplicate: `{}`\tfor\t`{}`", author_name, filename);

                        let mut new_filename =
                            path.file_stem().unwrap().to_str().unwrap().to_owned();
                        let extension = path.extension().unwrap().to_str().unwrap();
                        new_filename.push_str(" - ");
                        new_filename.push_str(
                            &std::time::SystemTime::now()
                                .duration_since(std::time::UNIX_EPOCH)
                                .unwrap()
                                .as_nanos()
                                .to_string(),
                        );
                        new_filename.push('.');
                        new_filename.push_str(extension);

                        log = format!("-Dupl- `{}`\tto\t`{}`\n", author_name, new_filename);

                        let new_path = PathBuf::from(author_path).join(new_filename);
                        fs::rename(path, new_path).unwrap();
                    }
                    log_file.write(log.as_bytes()).unwrap();
                    verbose_log_file.write(log.as_bytes()).unwrap();
                    continue;
                }
            } else if path.is_dir() {
                verbose_log_file
                    .write(format!("(Dir ) `{}`\n", path.display()).as_bytes())
                    .unwrap();

                fun_name(&path, &authors, log_file, verbose_log_file);
            }
        }
    }
}
